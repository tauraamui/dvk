fmt := import("fmt")
times := import("times")
metadata := import("metadata")

// LLF: Log level frequency
DVK_MODULE_CMD_ALIAS := "llf" // this is a required option "param"
DVK_SEEK_MIN := 0 // this is an optional param, default value is 0
DVK_SEEK_MAX := 100000 // this is an optional param, default value has not been decided yet

// metadata object:
// md.time
// md.level
// md.full_log
// md.log_text

main := func(logs) {
    last_found_time := undefined
    last_found_level := undefined
    last_date_format := undefined
    day_level_counts := {}
    for i := 0; i < len(logs); i++ {
        l := logs[i]
        md := metadata(l)

        last_found_time = md.time != undefined ? md.time : last_found_time
        last_found_level = md.level != undefined ? md.level : last_found_level
        md.time = md.time == undefined ? last_found_time : md.time
        md.level = last_found_level

        date := times.parse(times.format_ansic, md.time)
        if date == undefined { continue }
        date = times.time_format(date, "02Jan2006")

        dlc := day_level_counts[date]
        day_level_counts[date] = day_level_counts[date] == undefined ? {} : dlc
        cc := day_level_counts[date][md.level]
        cc = cc == undefined ? 1 : cc + 1
        day_level_counts[date][md.level] = cc

        if last_date_format != undefined && date != last_date_format {
            fmt.println(last_date_format, ": ", day_level_counts[last_date_format])
        }

        if i == len(logs)-1 {
            fmt.println(date, ": ", day_level_counts[date])
        }

        last_date_format = date != undefined ? date : last_date_format
    }
}
