fmt := import("fmt")
times := import("times")
text := import("text")

DVK_MODULE_CMD_ALIAS := "tsq" // this is a required option "param"
DVK_SEEK_MIN := 0 // this is an optional param, default value is 0
DVK_SEEK_MAX := 100000 // this is an optional param, default value has not been decided yet
DVK_OPT_LOG_TIME_FORMAT := "ansic"
DVK_OPT_QUERY_TIME_FORMAT := "2006"
DVK_OPT_LOG_LEVEL := "*"

time_formats := {
    "ansic": times.format_ansic,             // "Mon Jan _2 15:04:05 2006"
    "unix": times.format_unix_date,          // "Mon Jan _2 15:04:05 MST 2006"
    "ruby": times.format_ruby_date,          // "Mon Jan 02 15:04:05 -0700 2006"
    "rfc822": times.format_rfc822,           // "02 Jan 06 15:04 MST"
    "rfc822z": times.format_rfc822z,         // "02 Jan 06 15:04 -0700"
    "rfc850": times.format_rfc850,           // "Monday, 02-Jan-06 15:04:05 MST"
    "rfc1123": times.format_rfc1123,         // "Mon, 02 Jan 2006 15:04:05 MST"
    "rfc1123z": times.format_rfc1123z,       // "Mon, 02 Jan 2006 15:04:05 -0700"
    "rfc3339": times.format_rfc3339,         // "2006-01-02T15:04:05Z07:00"
    "rfc3339n": times.format_rfc3339_nano,   // "2006-01-02T15:04:05.999999999Z07:00"
    "kitchen": times.format_kitchen,         // "3:04PM"
    "stamp": times.format_stamp,             // "Jan _2 15:04:05"
    "stampmilli": times.format_stamp_milli,  // "Jan _2 15:04:05.000"
    "stampmicro": times.format_stamp_micro,  // "Jan _2 15:04:05.000000"
    "stampn": times.format_stamp_nano        // "Jan _2 15:04:05.000000000"
}

regexp_within_braces := `\[[^]]*\]` // matches all characters between '[' ']'

find_log_time_and_level := func(l, ut, ull) {
    time_and_level := { time: ut, level: ull }

    m := text.re_find(regexp_within_braces, l, 2)
    if m != undefined && len(m) >= 1 {
        if len(m[0]) == 1 {
            log_time := m[0][0].text
            log_time = text.trim_suffix(text.trim_prefix(log_time, "["), "]")
            time_and_level.time = times.parse(time_formats[DVK_OPT_LOG_TIME_FORMAT], log_time)
        }

        if len(m[1]) == 1 {
            log_level := m[1][0].text
            log_level = text.trim_suffix(text.trim_prefix(log_level, "["), "]")
            time_and_level.level = log_level
        }
    }
    return time_and_level
}

main := func(logs, start_date, end_date) {
    fmt.println("Data Visualisation Kit - Time Series Query")

    format := time_formats[DVK_OPT_LOG_TIME_FORMAT]
    if format == undefined {
        fmt.println("unknown time format: ", DVK_OPT_LOG_TIME_FORMAT)
        return
    }

    start_time := times.parse(DVK_OPT_QUERY_TIME_FORMAT, start_date)
    end_time := times.parse(DVK_OPT_QUERY_TIME_FORMAT, end_date)

    last_found_time := undefined
    last_found_level := undefined
    for l in logs {
        tll := find_log_time_and_level(l, last_found_time, last_found_level)
        last_found_time = tll.time
        last_found_level = tll.level
        if tll.time == undefined {
            continue
        }

        if DVK_OPT_LOG_LEVEL == "*" || DVK_OPT_LOG_LEVEL == tll.level {
            if times.after(tll.time, start_time) && times.before(tll.time, end_time) {
                fmt.println(l)
            }
        }
    }
}
