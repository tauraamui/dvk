fmt := import("fmt")
times := import("times")
text := import("text")

DVK_MODULE_CMD_ALIAS := "tsq" // this is a required option "param"
DVK_SEEK_MIN := 0 // this is an optional param, default value is 0
DVK_SEEK_MAX := 100000 // this is an optional param, default value has not been decided yet
DVK_OPT_LOG_TIME_FORMAT := "ansic"
DVK_OPT_QUERY_TIME_FORMAT := "2006"
DVK_OPT_LOG_LEVEL := "*"

time_formats := {
    "ansic": times.format_ansic,             // "Mon Jan _2 15:04:05 2006"
    "unix": times.format_unix_date,          // "Mon Jan _2 15:04:05 MST 2006"
    "ruby": times.format_ruby_date,          // "Mon Jan 02 15:04:05 -0700 2006"
    "rfc822": times.format_rfc822,           // "02 Jan 06 15:04 MST"
    "rfc822z": times.format_rfc822z,         // "02 Jan 06 15:04 -0700"
    "rfc850": times.format_rfc850,           // "Monday, 02-Jan-06 15:04:05 MST"
    "rfc1123": times.format_rfc1123,         // "Mon, 02 Jan 2006 15:04:05 MST"
    "rfc1123z": times.format_rfc1123z,       // "Mon, 02 Jan 2006 15:04:05 -0700"
    "rfc3339": times.format_rfc3339,         // "2006-01-02T15:04:05Z07:00"
    "rfc3339n": times.format_rfc3339_nano,   // "2006-01-02T15:04:05.999999999Z07:00"
    "kitchen": times.format_kitchen,         // "3:04PM"
    "stamp": times.format_stamp,             // "Jan _2 15:04:05"
    "stampmilli": times.format_stamp_milli,  // "Jan _2 15:04:05.000"
    "stampmicro": times.format_stamp_micro,  // "Jan _2 15:04:05.000000"
    "stampn": times.format_stamp_nano        // "Jan _2 15:04:05.000000000"
}

regexp_within_braces := `\[[^]]*\]` // matches all characters between '[' ']'

strip_meta_data := func(log_line) {
    meta_data := { time: undefined, level: undefined, full_log: log_line, log_text: undefined }

    matches := text.re_find(regexp_within_braces, log_line, 2)
    if matches != undefined {
        first_match_start_index := undefined
        first_match_end_index := undefined
        if len(matches) >= 1 {
            if m := matches[0]; len(m) >= 1 {
                m = m[0]
                first_match_start_index = m.begin
                first_match_end_index = m.end
                meta_data.time = text.trim_suffix(text.trim_prefix(m.text, "["), "]")
            }
        }

        second_match_start_index := undefined
        second_match_end_index := undefined
        if len(matches) >= 2 {
            if m := matches[1]; len(m) >= 1 {
                m = m[0]
                second_match_start_index = m.begin
                second_match_end_index = m.end
                meta_data.level = text.trim_suffix(text.trim_prefix(m.text, "["), "]")
            }
        }


        if first_match_start_index != undefined && first_match_end_index != undefined {
            // TODO(tauraamui): Re-think log content selecting
            // this is too destructive and still assumes that the matches
            // proceed the remaining log line's content, which is not certain
            log_line = log_line[first_match_start_index:][first_match_end_index:]
            if second_match_start_index != undefined && second_match_end_index != undefined {
                second_match_start_index = second_match_start_index - first_match_end_index
                second_match_end_index = second_match_end_index - first_match_end_index
            }
        }

        if second_match_start_index != undefined && second_match_end_index != undefined {
            log_line = log_line[second_match_start_index:][second_match_end_index:]
        }

        meta_data.log_text = log_line
    }

    return meta_data
}

main := func(logs, start_date, end_date) {
    fmt.println("Data Visualisation Kit - Time Series Query")

    format := time_formats[DVK_OPT_LOG_TIME_FORMAT]
    if format == undefined {
        fmt.println("unknown time format: ", DVK_OPT_LOG_TIME_FORMAT)
        return
    }

    start_time := times.parse(DVK_OPT_QUERY_TIME_FORMAT, start_date)
    end_time := times.parse(DVK_OPT_QUERY_TIME_FORMAT, end_date)

    last_found_time := undefined
    last_found_level := undefined
    for l in logs {
        md := strip_meta_data(l)

        if md.time != undefined {
            last_found_time = md.time
        } else {
            md.time = last_found_time
        }

        if md.level != undefined {
            last_found_level = md.level
        } else {
            md.level = last_found_level
        }

        if md.time == undefined {
            continue
        }

        log_time := times.parse(format, md.time)

        if DVK_OPT_LOG_LEVEL == "*" || DVK_OPT_LOG_LEVEL == md.level {
            if times.after(log_time, start_time) && times.before(log_time, end_time) {
                fmt.println(md.full_log)
            }
        }
    }
}
